<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D åƒç´ è¾²å ´éŠæˆ²</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .game-screen {
            position: relative;
            border: 4px solid #2E7D32;
            border-radius: 8px;
            background: #1B5E20;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        #gameCanvas {
            display: block;
            background: #87CEEB;
            border-radius: 4px;
        }
        
        .game-ui {
            width: 280px;
            background: linear-gradient(145deg, #2E7D32, #1B5E20);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        
        .ui-section {
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .ui-section h3 {
            color: #E8F5E8;
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
        }
        
        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .tool-btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            border: none;
            border-radius: 6px;
            padding: 8px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .tool-btn:hover {
            background: linear-gradient(145deg, #5CBF60, #4CAF50);
            transform: translateY(-1px);
        }
        
        .tool-btn.active {
            background: linear-gradient(145deg, #FF6B6B, #E55555);
            box-shadow: 0 0 10px rgba(255,107,107,0.5);
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            color: #E8F5E8;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            justify-items: center;
        }
        
        .control-key {
            background: linear-gradient(145deg, #666, #555);
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            min-width: 30px;
        }
        
        .control-key.arrow {
            background: linear-gradient(145deg, #4CAF50, #45a049);
        }
        
        .game-info {
            background: rgba(0,0,0,0.7);
            color: #00FF00;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .number-keys {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .number-key {
            background: linear-gradient(145deg, #FF6B6B, #E55555);
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-screen">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="game-ui">
            <div class="ui-section">
                <h3>ğŸ”§ å·¥å…·é¸æ“‡</h3>
                <div class="tool-grid">
                    <button class="tool-btn active" data-tool="hand">
                        âœ‹ æ‰‹
                    </button>
                    <button class="tool-btn" data-tool="hoe">
                        ğŸ› ï¸ é‹¤é ­
                    </button>
                    <button class="tool-btn" data-tool="seeds">
                        ğŸŒ± ç¨®å­
                    </button>
                    <button class="tool-btn" data-tool="watering_can">
                        ğŸš¿ æ¾†æ°´å£º
                    </button>
                </div>
                <div class="number-keys">
                    <div class="number-key">1</div>
                    <div class="number-key">2</div>
                    <div class="number-key">3</div>
                    <div class="number-key">4</div>
                </div>
            </div>
            
            <div class="ui-section">
                <h3>ğŸ“Š éŠæˆ²ç‹€æ…‹</h3>
                <div class="status-item">
                    <span>ğŸ’° é‡‘å¹£:</span>
                    <span id="goldCount">100</span>
                </div>
                <div class="status-item">
                    <span>ğŸŒ± ç¨®å­:</span>
                    <span id="seedCount">10</span>
                </div>
                <div class="status-item">
                    <span>ğŸŒ¾ æ”¶ç©«:</span>
                    <span id="harvestCount">0</span>
                </div>
                <div class="status-item">
                    <span>ğŸ”§ ç•¶å‰å·¥å…·:</span>
                    <span id="currentTool">æ‰‹</span>
                </div>
            </div>
            
            <div class="ui-section">
                <h3>ğŸ® æ§åˆ¶æ–¹å¼</h3>
                <div class="controls-grid">
                    <div></div>
                    <div class="control-key arrow">â†‘</div>
                    <div></div>
                    <div class="control-key arrow">â†</div>
                    <div class="control-key arrow">â†“</div>
                    <div class="control-key arrow">â†’</div>
                </div>
                <div style="text-align: center; margin-top: 10px; font-size: 10px; color: #E8F5E8;">
                    æ•¸å­—éµåˆ‡æ›å·¥å…· â€¢ ç©ºç™½éµä½¿ç”¨å·¥å…·
                </div>
            </div>
            
            <div class="ui-section">
                <h3>ğŸ“‹ éŠæˆ²è³‡è¨Š</h3>
                <div id="gameInfo" class="game-info">
                    æ­¡è¿ä¾†åˆ°åƒç´ è¾²å ´ï¼ä½¿ç”¨æ•¸å­—éµåˆ‡æ›å·¥å…·ï¼Œç©ºç™½éµä½¿ç”¨å·¥å…·ã€‚
                </div>
            </div>
        </div>
    </div>

    <script>
        class PixelFarmGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                this.gameState = {
                    player: {
                        x: 400,
                        y: 300,
                        direction: 'down',
                        speed: 2,
                        animFrame: 0,
                        animTimer: 0
                    },
                    camera: {
                        x: 0,
                        y: 0
                    },
                    tools: {
                        current: 'hand',
                        list: ['hand', 'hoe', 'seeds', 'watering_can']
                    },
                    resources: {
                        gold: 100,
                        seeds: 10,
                        harvest: 0
                    },
                    map: {
                        width: 40,
                        height: 30,
                        tileSize: 32
                    },
                    crops: [],
                    animals: [
                        { type: 'cow', x: 200, y: 150, mood: 'happy' },
                        { type: 'chicken', x: 600, y: 200, mood: 'happy' },
                        { type: 'sheep', x: 350, y: 400, mood: 'happy' }
                    ],
                    keys: {}
                };
                
                this.mapData = this.generateMap();
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.gameLoop();
                this.showInfo("æ­¡è¿ä¾†åˆ°åƒç´ è¾²å ´ï¼");
            }
            
            setupEventListeners() {
                // éµç›¤äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    this.gameState.keys[e.code] = true;
                    
                    // æ•¸å­—éµåˆ‡æ›å·¥å…·
                    if (e.code >= 'Digit1' && e.code <= 'Digit4') {
                        const toolIndex = parseInt(e.code.replace('Digit', '')) - 1;
                        if (toolIndex < this.gameState.tools.list.length) {
                            this.selectTool(this.gameState.tools.list[toolIndex]);
                        }
                    }
                    
                    // ç©ºç™½éµä½¿ç”¨å·¥å…·
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.useTool();
                    }
                    
                    // é˜²æ­¢æ–¹å‘éµæ»¾å‹•é é¢
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                        e.preventDefault();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.gameState.keys[e.code] = false;
                });
                
                // å·¥å…·æŒ‰éˆ•äº‹ä»¶
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tool = btn.getAttribute('data-tool');
                        this.selectTool(tool);
                    });
                });
            }
            
            generateMap() {
                const map = [];
                for (let y = 0; y < this.gameState.map.height; y++) {
                    map[y] = [];
                    for (let x = 0; x < this.gameState.map.width; x++) {
                        if (x === 0 || x === this.gameState.map.width - 1 || 
                            y === 0 || y === this.gameState.map.height - 1) {
                            map[y][x] = 3; // é‚Šç•Œæ°´åŸŸ
                        } else if (Math.random() < 0.1) {
                            map[y][x] = 2; // çŸ³é ­
                        } else {
                            map[y][x] = 1; // è‰åœ°
                        }
                    }
                }
                return map;
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                this.updatePlayer();
                this.updateCamera();
                this.updateCrops();
                this.updateUI();
            }
            
            updatePlayer() {
                const player = this.gameState.player;
                let moved = false;
                let newX = player.x;
                let newY = player.y;
                
                if (this.gameState.keys['ArrowUp']) {
                    newY -= player.speed;
                    player.direction = 'up';
                    moved = true;
                }
                if (this.gameState.keys['ArrowDown']) {
                    newY += player.speed;
                    player.direction = 'down';
                    moved = true;
                }
                if (this.gameState.keys['ArrowLeft']) {
                    newX -= player.speed;
                    player.direction = 'left';
                    moved = true;
                }
                if (this.gameState.keys['ArrowRight']) {
                    newX += player.speed;
                    player.direction = 'right';
                    moved = true;
                }
                
                // é‚Šç•Œæª¢æŸ¥
                const mapWidth = this.gameState.map.width * this.gameState.map.tileSize;
                const mapHeight = this.gameState.map.height * this.gameState.map.tileSize;
                
                newX = Math.max(32, Math.min(mapWidth - 64, newX));
                newY = Math.max(32, Math.min(mapHeight - 64, newY));
                
                // ç¢°æ’æª¢æ¸¬
                if (!this.checkCollision(newX, player.y)) {
                    player.x = newX;
                }
                if (!this.checkCollision(player.x, newY)) {
                    player.y = newY;
                }
                
                // å‹•ç•«æ›´æ–°
                if (moved) {
                    player.animTimer++;
                    if (player.animTimer > 8) {
                        player.animFrame = (player.animFrame + 1) % 4;
                        player.animTimer = 0;
                    }
                } else {
                    player.animFrame = 0;
                    player.animTimer = 0;
                }
            }
            
            checkCollision(x, y) {
                const corners = [
                    { x: Math.floor(x / 32), y: Math.floor(y / 32) },
                    { x: Math.floor((x + 30) / 32), y: Math.floor(y / 32) },
                    { x: Math.floor(x / 32), y: Math.floor((y + 30) / 32) },
                    { x: Math.floor((x + 30) / 32), y: Math.floor((y + 30) / 32) }
                ];
                
                for (let corner of corners) {
                    if (this.mapData[corner.y] && 
                        (this.mapData[corner.y][corner.x] === 3 || this.mapData[corner.y][corner.x] === 2)) {
                        return true;
                    }
                }
                return false;
            }
            
            updateCamera() {
                const player = this.gameState.player;
                this.gameState.camera.x = player.x - 400;
                this.gameState.camera.y = player.y - 300;
            }
            
            updateCrops() {
                this.gameState.crops.forEach(crop => {
                    if (!crop.ready) {
                        crop.growthTime++;
                        if (crop.growthTime >= crop.maxGrowthTime) {
                            crop.ready = true;
                        }
                    }
                });
            }
            
            updateUI() {
                document.getElementById('goldCount').textContent = this.gameState.resources.gold;
                document.getElementById('seedCount').textContent = this.gameState.resources.seeds;
                document.getElementById('harvestCount').textContent = this.gameState.resources.harvest;
                document.getElementById('currentTool').textContent = this.getToolName();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.renderMap();
                this.renderCrops();
                this.renderAnimals();
                this.renderPlayer();
                this.renderUI();
            }
            
            renderMap() {
                const camera = this.gameState.camera;
                const tileSize = this.gameState.map.tileSize;
                
                const startX = Math.floor(camera.x / tileSize);
                const startY = Math.floor(camera.y / tileSize);
                const endX = Math.min(startX + Math.ceil(this.canvas.width / tileSize) + 1, this.gameState.map.width);
                const endY = Math.min(startY + Math.ceil(this.canvas.height / tileSize) + 1, this.gameState.map.height);
                
                for (let y = Math.max(0, startY); y < endY; y++) {
                    for (let x = Math.max(0, startX); x < endX; x++) {
                        const screenX = x * tileSize - camera.x;
                        const screenY = y * tileSize - camera.y;
                        
                        switch (this.mapData[y][x]) {
                            case 1: // è‰åœ°
                                this.ctx.fillStyle = '#90EE90';
                                this.ctx.fillRect(screenX, screenY, tileSize, tileSize);
                                // æ·»åŠ è‰åœ°ç´‹ç†
                                this.ctx.fillStyle = '#7CFC00';
                                this.ctx.fillRect(screenX + 2, screenY + 2, 4, 4);
                                this.ctx.fillRect(screenX + 20, screenY + 10, 4, 4);
                                this.ctx.fillRect(screenX + 10, screenY + 25, 4, 4);
                                break;
                            case 2: // çŸ³é ­
                                this.ctx.fillStyle = '#696969';
                                this.ctx.fillRect(screenX, screenY, tileSize, tileSize);
                                this.ctx.fillStyle = '#808080';
                                this.ctx.fillRect(screenX + 4, screenY + 4, tileSize - 8, tileSize - 8);
                                break;
                            case 3: // æ°´åŸŸ
                                this.ctx.fillStyle = '#4682B4';
                                this.ctx.fillRect(screenX, screenY, tileSize, tileSize);
                                // æ°´æ³¢ç´‹ç†
                                this.ctx.fillStyle = '#5A9FD4';
                                this.ctx.fillRect(screenX + 2, screenY + 8, 28, 4);
                                this.ctx.fillRect(screenX + 2, screenY + 20, 28, 4);
                                break;
                        }
                    }
                }
            }
            
            renderPlayer() {
                const player = this.gameState.player;
                const screenX = player.x - this.gameState.camera.x;
                const screenY = player.y - this.gameState.camera.y;
                
                this.drawPixelCharacter(screenX, screenY, player.direction, player.animFrame);
            }
            
            drawPixelCharacter(x, y, direction, animFrame) {
                const ctx = this.ctx;
                
                // è§’è‰²é™°å½±
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(x + 6, y + 42, 20, 6);
                
                // è§’è‰²é…è‰²
                const colors = {
                    skin: '#F5DEB3',
                    hair: '#8B4513',
                    shirt: '#228B22',
                    pants: '#4169E1',
                    shoes: '#8B4513',
                    eye: '#000000',
                    outline: '#4A4A4A'
                };
                
                // ç¹ªè£½èº«é«”è¼ªå»“
                ctx.fillStyle = colors.outline;
                ctx.fillRect(x + 7, y + 1, 18, 46);
                
                // ç¹ªè£½é ­éƒ¨
                ctx.fillStyle = colors.skin;
                ctx.fillRect(x + 8, y + 2, 16, 14);
                
                // ç¹ªè£½é ­é«®
                ctx.fillStyle = colors.hair;
                switch (direction) {
                    case 'up':
                        ctx.fillRect(x + 6, y, 20, 8);
                        ctx.fillRect(x + 8, y + 8, 16, 4);
                        break;
                    case 'down':
                        ctx.fillRect(x + 6, y, 20, 10);
                        ctx.fillRect(x + 8, y + 10, 16, 2);
                        break;
                    case 'left':
                        ctx.fillRect(x + 6, y, 18, 8);
                        ctx.fillRect(x + 8, y + 8, 14, 4);
                        break;
                    case 'right':
                        ctx.fillRect(x + 8, y, 18, 8);
                        ctx.fillRect(x + 10, y + 8, 14, 4);
                        break;
                }
                
                // ç¹ªè£½çœ¼ç›
                ctx.fillStyle = colors.eye;
                switch (direction) {
                    case 'up':
                        break;
                    case 'down':
                        ctx.fillRect(x + 11, y + 8, 2, 2);
                        ctx.fillRect(x + 19, y + 8, 2, 2);
                        break;
                    case 'left':
                        ctx.fillRect(x + 10, y + 8, 2, 2);
                        break;
                    case 'right':
                        ctx.fillRect(x + 20, y + 8, 2, 2);
                        break;
                }
                
                // ç¹ªè£½å˜´å·´
                if (direction === 'down') {
                    ctx.fillStyle = '#FF6B6B';
                    ctx.fillRect(x + 15, y + 12, 2, 1);
                }
                
                // ç¹ªè£½èº«é«”
                ctx.fillStyle = colors.shirt;
                ctx.fillRect(x + 8, y + 16, 16, 12);
                
                // ç¹ªè£½æ‰‹è‡‚
                ctx.fillStyle = colors.skin;
                if (animFrame % 2 === 0) {
                    ctx.fillRect(x + 4, y + 18, 4, 8);
                    ctx.fillRect(x + 24, y + 18, 4, 8);
                } else {
                    ctx.fillRect(x + 4, y + 20, 4, 6);
                    ctx.fillRect(x + 24, y + 16, 4, 10);
                }
                
                // ç¹ªè£½è¤²å­
                ctx.fillStyle = colors.pants;
                ctx.fillRect(x + 8, y + 28, 16, 8);
                
                // ç¹ªè£½è…¿éƒ¨
                ctx.fillStyle = colors.skin;
                if (animFrame % 2 === 0) {
                    ctx.fillRect(x + 10, y + 36, 4, 6);
                    ctx.fillRect(x + 18, y + 36, 4, 6);
                } else {
                    switch (direction) {
                        case 'up':
                        case 'down':
                            ctx.fillRect(x + 8, y + 36, 4, 6);
                            ctx.fillRect(x + 20, y + 36, 4, 6);
                            break;
                        case 'left':
                            ctx.fillRect(x + 10, y + 36, 4, 6);
                            ctx.fillRect(x + 16, y + 36, 4, 6);
                            break;
                        case 'right':
                            ctx.fillRect(x + 12, y + 36, 4, 6);
                            ctx.fillRect(x + 18, y + 36, 4, 6);
                            break;
                    }
                }
                
                // ç¹ªè£½é‹å­
                ctx.fillStyle = colors.shoes;
                if (animFrame % 2 === 0) {
                    ctx.fillRect(x + 9, y + 42, 6, 4);
                    ctx.fillRect(x + 17, y + 42, 6, 4);
                } else {
                    ctx.fillRect(x + 8, y + 42, 6, 4);
                    ctx.fillRect(x + 18, y + 42, 6, 4);
                }
            }
            
            renderAnimals() {
                this.gameState.animals.forEach(animal => {
                    const screenX = animal.x - this.gameState.camera.x;
                    const screenY = animal.y - this.gameState.camera.y;
                    
                    if (screenX > -50 && screenX < 850 && screenY > -50 && screenY < 650) {
                        this.drawAnimal(screenX, screenY, animal);
                    }
                });
            }
            
            drawAnimal(x, y, animal) {
                const ctx = this.ctx;
                
                switch (animal.type) {
                    case 'cow':
                        // ç‰›çš„é™°å½±
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(x + 2, y + 28, 36, 4);
                        
                        // ç‰›èº«é«”
                        ctx.fillStyle = '#FFFACD';
                        ctx.fillRect(x, y + 8, 40, 20);
                        
                        // ç‰›é ­
                        ctx.fillStyle = '#F5DEB3';
                        ctx.fillRect(x + 10, y, 20, 16);
                        
                        // ç‰›çœ¼ç›
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x + 14, y + 4, 2, 2);
                        ctx.fillRect(x + 24, y + 4, 2, 2);
                        
                        // ç‰›é¼»å­
                        ctx.fillStyle = '#FF69B4';
                        ctx.fillRect(x + 18, y + 10, 4, 2);
                        
                        // ç‰›æ–‘é»
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x + 6, y + 12, 8, 6);
                        ctx.fillRect(x + 26, y + 16, 6, 6);
                        break;
                        
                    case 'chicken':
                        // é›çš„é™°å½±
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(x + 2, y + 20, 20, 3);
                        
                        // é›èº«é«”
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(x + 4, y + 8, 16, 12);
                        
                        // é›é ­
                        ctx.fillStyle = '#FFE4E1';
                        ctx.fillRect(x + 8, y + 4, 8, 8);
                        
                        // é›å† 
                        ctx.fillStyle = '#FF0000';
                        ctx.fillRect(x + 10, y, 4, 4);
                        
                        // é›çœ¼ç›
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x + 10, y + 6, 1, 1);
                        ctx.fillRect(x + 13, y + 6, 1, 1);
                        
                        // é›å˜´
                        ctx.fillStyle = '#FFA500';
                        ctx.fillRect(x + 6, y + 8, 2, 1);
                        break;
                        
                    case 'sheep':
                        // ç¾Šçš„é™°å½±
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.fillRect(x + 2, y + 26, 28, 4);
                        
                        // ç¾Šèº«é«”
                        ctx.fillStyle = '#FFFAFA';
                        ctx.fillRect(x, y + 8, 32, 18);
                        
                        // ç¾Šæ¯›è³ªæ„Ÿ
                        ctx.fillStyle = '#F0F8FF';
                        ctx.fillRect(x + 2, y + 10, 4, 4);
                        ctx.fillRect(x + 8, y + 12, 4, 4);
                        ctx.fillRect(x + 16, y + 10, 4, 4);
                        ctx.fillRect(x + 22, y + 12, 4, 4);
                        
                        // ç¾Šé ­
                        ctx.fillStyle = '#F5DEB3';
                        ctx.fillRect(x + 10, y, 12, 12);
                        
                        // ç¾Šçœ¼ç›
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x + 13, y + 4, 2, 2);
                        ctx.fillRect(x + 17, y + 4, 2, 2);
                        break;
                }
            }
            
            renderCrops() {
                this.gameState.crops.forEach(crop => {
                    const screenX = crop.x - this.gameState.camera.x;
                    const screenY = crop.y - this.gameState.camera.y;
                    
                    if (screenX > -32 && screenX < 832 && screenY > -32 && screenY < 632) {
                        this.drawCrop(screenX, screenY, crop);
                    }
                });
            }
            
            drawCrop(x, y, crop) {
                const ctx = this.ctx;
                const growthStage = Math.min(3, Math.floor(crop.growthTime / (crop.maxGrowthTime / 4)));
                
                // åœŸå£¤
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x, y + 24, 32, 8);
                
                switch (growthStage) {
                    case 0:
                        // ç¨®å­
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(x + 14, y + 26, 4, 2);
                        break;
                    case 1:
                        // å¹¼è‹—
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(x + 14, y + 20, 4, 12);
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(x + 12, y + 18, 2, 4);
                        ctx.fillRect(x + 18, y + 18, 2, 4);
                        break;
                    case 2:
                        // æˆé•·ä¸­
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(x + 14, y + 16, 4, 16);
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(x + 10, y + 14, 4, 8);
                        ctx.fillRect(x + 18, y + 14, 4, 8);
                        break;
                    case 3:
                        // æˆç†Ÿ
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(x + 14, y + 12, 4, 20);
                        ctx.fillStyle = '#32CD32';
                        ctx.fillRect(x + 8, y + 10, 6, 10);
                        ctx.fillRect(x + 18, y + 10, 6, 10);
                        
                        if (crop.ready) {
                            ctx.fillStyle = '#FFD700';
                            ctx.fillRect(x + 10, y + 6, 6, 6);
                            ctx.fillRect(x + 16, y + 8, 6, 6);
                        }
                        break;
                }
            }
            
            renderUI() {
                // ç•¶å‰å·¥å…·æŒ‡ç¤º
                if (this.gameState.tools.current !== 'hand') {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.ctx.fillRect(10, 10, 200, 30);
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = '16px monospace';
                    this.ctx.fillText(`ç•¶å‰å·¥å…·: ${this.getToolName()}`, 20, 30);
                }
            }
            
            selectTool(tool) {
                this.gameState.tools.current = tool;
                
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
                
                this.showInfo(`é¸æ“‡å·¥å…·: ${this.getToolName()}`);
            }
            
            getToolName() {
                const names = {
                    'hand': 'æ‰‹',
                    'hoe': 'é‹¤é ­',
                    'seeds': 'ç¨®å­',
                    'watering_can': 'æ¾†æ°´å£º'
                };
                return names[this.gameState.tools.current] || 'æœªçŸ¥';
            }
            
            useTool() {
                const player = this.gameState.player;
                const tileX = Math.floor(player.x / 32);
                const tileY = Math.floor(player.y / 32);
                
                switch (this.gameState.tools.current) {
                    case 'hoe':
                        this.hoeTile(tileX, tileY);
                        break;
                    case 'seeds':
                        this.plantSeeds(tileX, tileY);
                        break;
                    case 'watering_can':
                        this.waterCrops(tileX, tileY);
                        break;
                    case 'hand':
                        this.harvestCrops(tileX, tileY);
                        break;
                }
            }
            
            hoeTile(tileX, tileY) {
                if (this.mapData[tileY] && this.mapData[tileY][tileX] === 1) {
                    this.mapData[tileY][tileX] = 0; // è€•åœ°
                    this.showInfo("ğŸ”¨ è€•åœ°å®Œæˆï¼");
                } else {
                    this.showInfo("âŒ ç„¡æ³•åœ¨æ­¤è™•è€•åœ°ï¼");
                }
            }
            
            plantSeeds(tileX, tileY) {
                if (this.gameState.resources.seeds <= 0) {
                    this.showInfo("âŒ æ²’æœ‰ç¨®å­äº†ï¼");
                    return;
                }
                
                if (this.mapData[tileY] && this.mapData[tileY][tileX] === 0) {
                    const existingCrop = this.gameState.crops.find(crop => 
                        Math.floor(crop.x / 32) === tileX && Math.floor(crop.y / 32) === tileY
                    );
                    
                    if (!existingCrop) {
                        this.gameState.crops.push({
                            x: tileX * 32,
                            y: tileY * 32,
                            growthTime: 0,
                            maxGrowthTime: 300,
                            ready: false
                        });
                        this.gameState.resources.seeds--;
                        this.showInfo("ğŸŒ± ç¨®å­å·²ç¨®æ¤ï¼");
                    } else {
                        this.showInfo("âŒ é€™è£¡å·²ç¶“æœ‰ä½œç‰©äº†ï¼");
                    }
                } else {
                    this.showInfo("âŒ éœ€è¦å…ˆè€•åœ°ï¼");
                }
            }
            
            waterCrops(tileX, tileY) {
                const crop = this.gameState.crops.find(crop => 
                    Math.floor(crop.x / 32) === tileX && Math.floor(crop.y / 32) === tileY
                );
                
                if (crop && !crop.ready) {
                    crop.growthTime += 50;
                    this.showInfo("ğŸ’§ æ¾†æ°´å®Œæˆï¼ä½œç‰©æˆé•·åŠ é€Ÿï¼");
                } else if (crop && crop.ready) {
                    this.showInfo("ğŸ’§ ä½œç‰©å·²ç¶“æˆç†Ÿäº†ï¼");
                } else {
                    this.showInfo("âŒ é€™è£¡æ²’æœ‰ä½œç‰©ï¼");
                }
            }
            
            harvestCrops(tileX, tileY) {
                const cropIndex = this.gameState.crops.findIndex(crop => 
                    Math.floor(crop.x / 32) === tileX && Math.floor(crop.y / 32) === tileY
                );
                
                if (cropIndex !== -1) {
                    const crop = this.gameState.crops[cropIndex];
                    if (crop.ready) {
                        this.gameState.crops.splice(cropIndex, 1);
                        this.gameState.resources.harvest++;
                        this.gameState.resources.gold += 20;
                        this.gameState.resources.seeds += 2;
                        this.showInfo("ğŸŒ¾ æ”¶ç©«æˆåŠŸï¼ç²å¾— 20 é‡‘å¹£å’Œ 2 é¡†ç¨®å­ï¼");
                    } else {
                        this.showInfo("âŒ ä½œç‰©é‚„æ²’æˆç†Ÿï¼");
                    }
                } else {
                    this.showInfo("âŒ é€™è£¡æ²’æœ‰ä½œç‰©ï¼");
                }
            }
            
            showInfo(message) {
                const infoElement = document.getElementById('gameInfo');
                if (infoElement) {
                    infoElement.style.transform = 'scale(1.05)';
                    infoElement.style.color = '#00FF00';
                    infoElement.textContent = message;
                    
                    setTimeout(() => {
                        infoElement.style.transform = 'scale(1)';
                        infoElement.style.color = '#00FF00';
                    }, 200);
                    
                    setTimeout(() => {
                        infoElement.textContent = 'æ­¡è¿ä¾†åˆ°åƒç´ è¾²å ´ï¼ä½¿ç”¨æ•¸å­—éµåˆ‡æ›å·¥å…·ï¼Œç©ºç™½éµä½¿ç”¨å·¥å…·ã€‚';
                    }, 3000);
                }
            }
        }
        
        // å•Ÿå‹•éŠæˆ²
        document.addEventListener('DOMContentLoaded', () => {
            const game = new PixelFarmGame();
            console.log('2D åƒç´ è¾²å ´éŠæˆ²å·²å•Ÿå‹•ï¼');
        });
    </script>
</body>
</html>